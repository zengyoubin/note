# MySQL基本架构

### MySQL可以分为两层Server层和存储引擎层。

![MySQL逻辑架构图](image/0d2070e8f84c4801adbfa03bda1f98d9.png)

#### Server层

#### 连接器

​	连接器负责跟客户端建立连接、获取权限、维持和管理连接。

​	客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 `wait_timeout` 控制的，默认值是 **8** 小时

#### 查询缓存

​	MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。

​	如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL 不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。

​	查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。

​	**对于更新操作频繁的表查询缓存往往弊大于利**

​	MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。

#### 分析器

​	分析器先会做“词法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

#### 优化器

​	优化器是在表里面有多个索引的时候，决定使用哪个索引。

#### 执行器

​	开始执行的时候，要先判断用户对该表有查询权限，没有则返回没有权限错误。（在命中缓存时，会再查询缓存返回寄过的时候做权限验证，查询也会在优化器之前调用precheck验证权限）。

​	接下来执行器会根据标的引擎定义，去使用这个引擎提供的接口。

# 日志模块

主要是Server层的`binlog`和Inno DB存储引擎层的`redo log 、undo log`

### 重要的日志模块：redo log

##### WAL（Wirte-Ahead Logging）

​	先写日志，再写磁盘。具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。

##### redo log

​	InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写。

![redo log](image/16a7950217b3f0f4ed02db5db59562a7.png)

- `write pos` 是当前记录的位置，一边写一遍后移
- `check point` 是当前要擦除的位置，往后推移并且循环，擦除记录前要把记录更新到数据文件。
- `write pos` 和`check point`之间空着的部分，可以用来记录新的操作。如果`write pos`追上`check point`，表示redo log满了，这时候不能再执行新的更新，得停下里先擦掉一些记录，把`check point`往前推进。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 `crash-safe`。

#### 重要参数

##### `innodb_flush_log_at_trx_commit`

​	这个参数设置成1，表示每次事务的redo log都直接持久化到磁盘。

### 重要的日志模块：binlog

​	binlog属于Server层，不具备`crash-safe`能力，只能用于归档。

#### 重要参数

`sync_binlog`

​	这个参数设置成1，表示每次事务的binlog都持久化到磁盘。

### binlog和redo log区别

1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2. redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志

### 两阶段提交

​	update语句更新流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![mysql update 更新流程如](image/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)



# 事务

​	**ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）**

​	当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）**的问题，为了解决这些问题，就有了“**隔离级别**”的概念。

​	SQL 标准的事务隔离级别包括：**读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）**

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 事务隔离的实现

​	在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值（即是undo log）。

![undo log示意图](image/d9c313809e5ac148fc39feff532f0fee.png)

​	如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的**多版本并发控制（MVCC）**。undo log在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些undo log时，回滚日志会被删除。

###### 查看长事务

​	可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

# 索引

​	索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。

### 索引的常见模型

三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。

- 哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。
- 有序数组索引只适用于静态存储引擎
- N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。

### InnoDB 的索引模型

​	在 InnoDB 中，表都是根据**主键顺序以索引的形式存放**的，这种存储方式的表称为**索引组织表**。InnoDB 使用了 **B+ 树索引模型**，所以数据都是存储在 B+ 树中的。

###### 示例

​	假设，我们有一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引。

​	这个表的建表语句是：

```sql

create table T(
  id int primary key, 
  k int not null, 
  name varchar(16),
  index (k)
)engine=InnoDB;
```

​	表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。

![inno db 索引组织结构图](image/dcda101051f28502bd5c4402b292e38d.png)

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

- 主键索引的叶子节点存的是**整行数据**。在 InnoDB 里，主键索引也被称为**聚簇索引（clustered index）**。

- 非主键索引的叶子节点内容是**主键的值**。在 InnoDB 里，非主键索引也被称为**二级索引（secondary index）**。

**基于主键索引和普通索引的查询的区别**

- 如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；
- 如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。

#### 索引维护

​	B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。

​	而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。

​	当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。

​	**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**

#### 覆盖索引

​	**覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

#### 最左前缀原则

​	**B+树的索引结构，可以利用索引的“最左前缀”，来定位记录。**

​	如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

#### 索引下推

​	MySQL5.6引入索引下推优化（index condition pushdown），可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

# MySQL锁

​	**根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类。**

## 全局锁

​	**全局锁是对整个数据库实例加锁，典型使用场景是，做全库逻辑备份。**命令是`Flush tables with read lock (FTWRL)`

​	官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数`–single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

​	**一致性读是好，但前提是引擎要支持这个隔离级别。**比如，对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。所以，**single-transaction 方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。

## 表级锁

